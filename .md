# Scoring: Kailyn Pudleiner and Will Stanziano. 

For the scoring section of the project, we explored a few different routes for the scoring algorithm, and focused most of our attention on cutting down the write time of the scoring information. For our final method, we ended up creating a class: ScoringDeckPd, a representation of a deck, that has methods to both sort and save the scoring information. The class stores to string representation of the deck, and performs the scoring method ._score_deck. This method takes the deck and player choices as input. It finds the first instance of each pattern, returns them, and locates pattern that occurs first (also taking into account if the pattern is not found). It then discards those cards and incriments the winning players count. It utilizes string methods such as .find to find the pattern and simple indexing to get rid of cards. An example of the logic can be found below.

P1 Choice: 111\
P2 Choice: 001\
Deck: 1101011110001011100110110010101000011001000100011000

### Round 0:
|P1 Tricks  |P2 Tricks  |P1 Cards  |P2 Cards  |
|-----------|-----------|----------|----------|
|0          |0          |0         |0         |

### Round 1: 
11010<u>111</u> **|** 10<u>001</u>011100110110010101000011001000100011000
|P1 Tricks  |P2 Tricks  |P1 Cards  |P2 Cards  |
|-----------|-----------|----------|----------|
|1          |0          |8         |0         |

### Round 2:

10<u>001</u> **|** 0<u>111</u>001101100101010000110010001000110001
|P1 Tricks  |P2 Tricks  |P1 Cards  |P2 Cards  |
|-----------|-----------|----------|----------|
|1          |1          |8         |5         |

This pattern would continue until there are not enough cards left, or neither pattern is found. The method then outputs a single dictionary with the deck, player 1s choice, player 2s choice, player 1's tricks, player 2's tricks, player 1's cards, and player 2's cards. A seperate method calls this scoring method while cycling through all 56 player choice combinations. These 56 results are put into a pandas dataframe, which is then added to the deck_score table of the deck_scoring.sqlite database. In order to summarize the wins and losses for each of the 56 player combinations, we created a view. The view tallies when player one has more tricks than player two, etc, and summarizes that information in a table.That table is then what was saved to the csv.

## String versus Array

Based on part one of the project, we decided to generate the decks as numpy arrays of 0s and 1s, and store them as .npy files. This means we then read the decks back in as arrays of integers as we wrote them. However, after begining to score the decks in this manner, it quickly became evident that scoring them as strings would likely be easier. For example, to find the first iteration of a sequence of three digits, strings have a very convenient .find() method, instead of incrimenting through the whole deck manually. Additionally, strings serve as easy dictionary keys, which is something we had in our original code. Hence, for these reasons we decided to represent the deck as a single string of 1s and 0s instead of an array of integers. We plan to go back and edit our generation methods to make it more compatable with out search method.

## Storage Method

Based on the fact that we would need to store over 100 million rows of scoring information, we decided that it would be best to store these in a sqlite databsae. Hence, we utalized BaseDB from databases to create a database. However, the best way to go about adding scores to the database proved difficult. Below are the two different methods we implimented.

Method 1 (ScoringDeck): This 

Method 2: Generates 2,000,000 "decks" of 52 cards by using a for loop to generate a binary array of randomly shuffled collection of 26 0's and 26 1's. The collection of these are then saved into binary (.bin) files of 10,000 decks each.


## Results

For each method, we created 200 sets of 10,000 decks, leading to 2,000,000 decks. Using decorators, we recorded deck generation time, file size, read time, and write time. These values were stored in "Deck_Stats.csv" and the average were calculated. The table below diplays the meads plus or minus one standard deviation.

|Method        |Generation Time (s) |File Size (mb) |Write Time (s)    |Read Time (s)      |
|--------------|--------------------|---------------|------------------|-------------------|
|Method 1: NPY |0.03908 +- 0.02317  |0.49603 +- 0.0 |0.03255 +- 0.01591|0.15092 +- 0.06662 |
|Method 2: BIN |0.21017 +- 0.12178  |0.49591 +- 0.0 |0.01120 +- 0.00908|0.04126 +- 0.01134 |

At first glance, you may notice that method two wins in three out of the four categories. It has a much smaller read and write time, as well as a slightly smaller file size. However, it's generation time is much greater that of method one. This is likely due to the for loops present in method two that are noticeably absent form method one. When we add together the generation, read, and write times, method one actually has a slightly faster time of 0.22255 seconds compared to 0.26263 seconds for method 2. The total time and storage difference is somewhat negligible between the two methods.

## Conclusion

Some may argue that the extra time making the .bin file is unimportant since that will only be done once when the decks are created. However, there are a couple other problems with this method that may occur when scoring comes into play. Method two reads in the decks in a one-dimensional fashion instead of two-dimensional. This means we will have to continuously select the first 52 integers in order to score, instead of simply selecting the first array. It's also notable that numpy arrays have a myriad of functions that can assist in searching and scoring, which will likely be advantageous. Hence, despite the slightly smaller size and faster generation time read of method two, we believe method one will be more fortuitus in the long run.

